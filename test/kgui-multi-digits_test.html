<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>kgui-multi-digits test</title>

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>

    <link rel="import" href="../kgui-multi-digits.html">
  </head>
  <body>
    <test-fixture id="basic">
      <template>
        <kgui-multi-digits></kgui-multi-digits>
      </template>
    </test-fixture>

    <script>
      /* global
          suite, setup, fixture, test, assert
       */

      suite('kgui-multi-digits', function() {
        var decimalSeparator = (1.1).toLocaleString().replace(/1/g, ''); // Equivalent to element.localDecimal
        var element;

        /**
         * To fire a CLICK event on those ADD, SUBTRACT buttons.
         * @param {Element} el element object to dispatch the EVENT `type` on.
         * @param {String} eType stands for EventType
         */
        function eventFire(el, eType) {
          if (el.fireEvent) {
            el.fireEvent('on' + eType);
          } else {
            var evObj = document.createEvent('Events');
            evObj.initEvent(eType, true, false);
            el.dispatchEvent(evObj);
          }
        }

        // -----------------------------------------------------------------------------------
        // NOTES
        // Some test are not in logical order; parameters, properties, functions internal, external and integration.
        // Some test are double, just to be sure test is complyant to default situation, or prepared situation.
        //
        // BE WARNED
        // The element `kgui-multi-digits` has LOCALIZED behavior. Meaning in some countries
        // the JavaScript value of '1.8', is displayed, entered as '1,8'.
        // Test are aware of this localization.
        // -----------------------------------------------------------------------------------

        // -----------------------------------------------------------------------------------
        // Test preparation
        // -----------------------------------------------------------------------------------

        // Will be executed at the beginning of every test().
        setup(function() {
          element = fixture('basic');
        });

        // -----------------------------------------------------------------------------------
        // Elementary
        // -----------------------------------------------------------------------------------

        test('A01 - Instantiating the default element works.', function() {
          assert.equal(element.is, 'kgui-multi-digits');
        });

        test('A02 - Check CORE data for default format `(##)#`.', function() {
          assert.equal(element.format, '(##)#');
          assert.equal(element.getAttribute('format'), '(##)#');

          assert.equal(element.localDecimal, decimalSeparator);

          // Check _core data, the number of digits (not symbols, 4 in this example)
          assert.equal(element._core.digitCount, 3);

          if (decimalSeparator === ',') { // Continental European
            assert.equal(element.localDecimal, ','); // WARNING: Is localized data
            assert.equal(element._core.thousandSeparator, '.'); // WARNING: Is localized data
          } else {
            assert.equal(element.localDecimal, '.'); // WARNING: Is localized data
            assert.equal(element._core.thousandSeparator, ','); // WARNING: Is localized data
          }

          assert.equal(element._core.decimalCount, 3); // Number (digits) before DECIMAL MARK
          assert.equal(element._core.fractionCount, 0); // Number (digits) after DECIMAL MARK
          assert.equal(element._core.formatDecimalMarkPosition, null); // Counting from left to right, start at zero.
          assert.equal(element._core.formatAsZeroNumber, '000');
          assert.equal(element._core.digitCount, 3); // Symbols are #, DECIMAL and THOUSAND marks

          // Sybols list '_core.symbols'
          assert.equal(element._core.symbols.length, 3); // Symbols are #, DECIMAL and THOUSAND marks
          assert.equal(element._core.symbols[0].id, 'digit0'); // From RIGHT to LEFT
          assert.equal(element._core.symbols[0].isDecimal, false); // Is symbol identified as LOCAL a DECIMAL MARK
          assert.equal(element._core.symbols[0].isThousand, false); // Is symbol identified as LOCAL a THOUSANDS MARK
          assert.equal(element._core.symbols[0].isDivider, false);
          assert.equal(element._core.symbols[0].isDigit, true);
          assert.equal(element._core.symbols[0].isOptional, false);

          assert.equal(element._core.symbols[1].id, 'digit1'); // From RIGHT to LEFT
          assert.equal(element._core.symbols[1].isDecimal, false); // Is symbol identified as LOCAL a DECIMAL MARK
          assert.equal(element._core.symbols[1].isThousand, false); // Is symbol identified as LOCAL a THOUSANDS MARK
          assert.equal(element._core.symbols[1].isDigit, true);
          assert.equal(element._core.symbols[1].isOptional, true);

          assert.equal(element._core.symbols[2].id, 'digit2'); // From RIGHT to LEFT
          assert.equal(element._core.symbols[2].isDecimal, false); // Is symbol identified as LOCAL a DECIMAL MARK
          assert.equal(element._core.symbols[2].isThousand, false); // Is symbol identified as LOCAL a THOUSANDS MARK
          assert.equal(element._core.symbols[2].isDigit, true);
          assert.equal(element._core.symbols[2].isOptional, true);

          element.format = '#';
          element.removeAttribute('format');
          assert.equal(element.hasAttribute('format'), true); // Because, element need always a format String.
          assert.equal(element.format, '(##)#');
        });

        test('A03 - Check absence of format string, forcing default.', function() {
          // Prepare test
          assert.equal(element.format, '(##)#');
          element.format = '#';
          assert.equal(element.getAttribute('format'), '#');
          // Test
          element.removeAttribute('format');
          assert.equal(element.hasAttribute('format'), true); // Because, element always need a format String.
          assert.equal(element.format, '(##)#');
          assert.equal(element.getAttribute('format'), '(##)#');
        });

        test('A04 - Check default number value `0`.', function() {
          assert.equal(element.number, '0'); // This is the LOCALIZED version
          assert.equal(element._number, 0); // This is the value
          assert.equal(element.getAttribute('number'), '0');
        });

        test('A05 - Check absence of number value.', function() {
          assert.equal(element.number, '0'); // Default situation

          element.number = '9';
          assert.equal(element.getAttribute('number'), '9');
          assert.equal(element._number, 9);

          element.removeAttribute('number');
          // Normal behavior Polymer 1
          // Because it's a number it will reset to value of 0.
          // Where JavaScript behavior should say 'null'.
          // THAT IS WHY element.number is a String. '' Acts as unset.
          assert.equal(element.number, '0');
          assert.equal(element.hasAttribute('number'), true);
          assert.equal(element.getAttribute('number'), '0');
          assert.equal(element._number, 0);
        });

        // -----------------------------------------------------------------------------------
        // Function isValidLocalNumber(`number`)
        // Returns TRUE if a valid local DECIMAL MARKED number was given ('.' or ',').
        // TODO: Support for negative numbers
        // -----------------------------------------------------------------------------------

        test('B01 - Function isValidLocalNumber() return true, if valid number like (1.5 or 1,5).', function() {
          // Some acceptable numbers
          assert.equal(element.isValidLocalNumber(1), true); // Just one digit
          assert.equal(element.isValidLocalNumber('1'), true); // Just one digit
          assert.equal(element.isValidLocalNumber(99), true); // two digits
          assert.equal(element.isValidLocalNumber(123456789), true); // A lot digits

          assert.equal(element.isValidLocalNumber('1,1'), true); // Because it's Dutch local
          assert.equal(element.isValidLocalNumber('1.2'), true); // Because it's international, JavaScript

          // Some false
          assert.equal(element.isValidLocalNumber('1:1'), false);
          assert.equal(element.isValidLocalNumber('2,2.'), false);
          assert.equal(element.isValidLocalNumber('3.3.'), false);
          assert.equal(element.isValidLocalNumber('4,4,'), false);
        });

        // -----------------------------------------------------------------------------------
        // Function validateFormat(`format`)
        // Return TRUE when `format` is VALID.
        // THROWS an descriptive JavaScript error when INVALID AND uses the default value (##)#.
        // -----------------------------------------------------------------------------------

        test('B02 - Function validateFormat(NO DECIMAL MARKER) behaviour, updates CORE data.', function() {
          // Some acceptable formats
          assert.equal(element.validateFormat('#'), true); // Just one digit
          // Check _core data
          element.setAttribute('format', '#');
          assert.equal(element._core.digitCount, 1); // The number od actual digits, identified by (#)
          assert.equal(element._core.decimalCount, 1); // No DECIMAL MARKER available
          assert.equal(element._core.fractionCount, 0);
          assert.equal(element._core.formatDecimalMarkPosition, null); // Counting from left to right, start at zero.

          assert.equal(element.validateFormat('##########'), true); // Ten digits, stress test
          element.setAttribute('format', '##########');
          // Check _core data
          assert.equal(element._core.digitCount, 10);
          assert.equal(element._core.decimalCount, 10); // No DECIMAL MARKER available
          assert.equal(element._core.fractionCount, 0);
          assert.equal(element._core.formatDecimalMarkPosition, null); // Counting from richt to left, start at zero.
        });

        test('B03 - Function validateFormat(WITH LOCAL DECIMAL MARKER) behaviour, updated CORE data.', function() {
          assert.equal(element.validateFormat('#,#'), true); // Continental European
          assert.equal(element.validateFormat('#####,#####'), true); // Continental European
          assert.equal(element.validateFormat('#.#'), true); // International
          assert.equal(element.validateFormat('#####.#####'), true); // International
          assert.equal(element.validateFormat('##.#'), true); // 00,0
          assert.equal(element.validateFormat('(#)#.#'), true); // (0)0,0
          assert.equal(element.validateFormat('#,###.##'), true); // 0,000.00
          assert.equal(element.validateFormat('(#.#).#.#'), true); // (0.0).0.0

          // Test depends on DECIMAL MARKER TYPE - Continental European ','or '.'
          // Check _core data SIMPLE '#?#'
          if (decimalSeparator === ',') { // Continental European
            element.setAttribute('format', '#,#');
            assert.equal(element.localDecimal, ',');
          } else {
            element.setAttribute('format', '#.#');
            assert.equal(element.localDecimal, '.');
          }
          assert.equal(element._core.decimalCount, 1);
          assert.equal(element._core.fractionCount, 1);
          assert.equal(element._core.digitCount, 2);
          assert.equal(element._core.formatDecimalMarkPosition, 1); // Counting from richt to left, start at zero.
          assert.equal(element._core.formatAsZeroNumber, '0.0');

          // Check _core data complex '(##)#?###?###' - THOUSAND MARKS
          if (decimalSeparator === ',') { // Continental European
            element.setAttribute('format', '(##)#.###,###');
          } else {
            element.setAttribute('format', '(##)#,###.###');
          }
          assert.equal(element._core.digitCount, 9); // Digits only
          assert.equal(element._core.symbols.length, 11); // Digits plus markers (DECIMAL, THOUSAND)
          assert.equal(element._core.fractionCount, 3);
          assert.equal(element._core.decimalCount, 6);
          assert.equal(element._core.formatDecimalMarkPosition, 6); // Counting from left to right, start at zero.
          assert.equal(element._core.formatAsZeroNumber, '000000.000');

          // Check some core symbol data for '(##)#,###.###'
          // Digit ID count: (87)6,543.210
          // Token ID count: 0123456789012
          assert.equal(element._core.symbols[0].id, 'digit0'); // From RIGHT to LEFT
          assert.equal(element._core.symbols[0].isDecimal, false); // Is symbol identified as LOCAL a DECIMAL MARK
          assert.equal(element._core.symbols[0].isThousand, false); // Is symbol identified as LOCAL a THOUSANDS MARK
          assert.equal(element._core.symbols[0].isDivider, false);
          assert.equal(element._core.symbols[0].isDigit, true);
          assert.equal(element._core.symbols[0].isOptional, false);

          assert.equal(element._core.symbols[3].id, 'token9'); // From LEFT to RIGHT
          assert.equal(element._core.symbols[3].isDecimal, true); // Is symbol identified as LOCAL a DECIMAL MARK
          assert.equal(element._core.symbols[3].isThousand, false); // Is symbol identified as LOCAL a THOUSANDS MARK
          assert.equal(element._core.symbols[3].isDivider, true);
          assert.equal(element._core.symbols[3].isDigit, false);
          assert.equal(element._core.symbols[3].isOptional, false);

          assert.equal(element._core.symbols[7].id, 'token5'); // From LEFT to RIGHT
          assert.equal(element._core.symbols[7].isDecimal, false); // Is symbol identified as LOCAL a DECIMAL MARK
          assert.equal(element._core.symbols[7].isThousand, true); // Is symbol identified as LOCAL a THOUSANDS MARK
          assert.equal(element._core.symbols[7].isDivider, true);
          assert.equal(element._core.symbols[7].isDigit, false);
          assert.equal(element._core.symbols[7].isOptional, false);

          assert.equal(element._core.symbols[9].id, 'digit7'); // From RIGHT to LEFT
          assert.equal(element._core.symbols[9].isDecimal, false); // Is symbol identified as LOCAL a DECIMAL MARK
          assert.equal(element._core.symbols[9].isThousand, false); // Is symbol identified as LOCAL a THOUSANDS MARK
          assert.equal(element._core.symbols[9].isDivider, false);
          assert.equal(element._core.symbols[9].isDigit, true);
          assert.equal(element._core.symbols[9].isOptional, true);
        });

        test('B04 - Function validateFormat() unaccepted formats.', function() {
          // Unacceptable formats will throw ERRORS to console.
          // But, will use the default format (##)#.
          assert.throws(function() {
            element.validateFormat('a');
          }, 'Always start with `#` OR `(#` and always end with an `#`');

          assert.throws(function() {
            element.validateFormat('#(#)');
          }, 'Always start with `#` OR `(#` and always end with an `#`');

          /* All characters allowed except '(', ')'
           * Because they are part of the format string characters.
          assert.throws(function() {
            element.validateFormat('(#a)#');
          }, 'Allowed characters `.,#()Space:`');
          */

          assert.throws(function() {
            element.validateFormat('(#');
          }, 'Missing end `)`');

          assert.throws(function() {
            element.validateFormat('(#))#');
          }, 'No matching `()`.');

          assert.throws(function() {
            element.validateFormat('#)#');
          }, 'No matching `()`.');

          assert.throws(function() {
            element.validateFormat('(#(#))#');
          }, 'No matching `()`.');

          assert.throws(function() {
            element.validateFormat('(#(#)#');
          }, 'No matching `()`.');
        });

        test('B05 - Get maximum number specified by format, as _core data.', function() {
          element.setAttribute('format', '#');
          assert.equal(element._core.maxNumber, 9); // Negative not supported

          element.setAttribute('format', '######'); // 6 digits x '9'
          assert.equal(element._core.maxNumber, 999999);

          // Test depends on LOCAL US '9,999,999.99' and or European '9.999.999,99'.
          if (decimalSeparator === ',') { // Continental European
            assert.equal(element.getAttribute('local-decimal'), ','); // Negative not supported

            element.setAttribute('format', '#,#');
            assert.equal(element._core.maxNumber, 9.9);

            element.setAttribute('format', '#,###');
            assert.equal(element._core.maxNumber, 9.999);

            element.setAttribute('format', '(###)#,#');
            assert.equal(element._core.maxNumber, 9999.9);

            element.setAttribute('format', '(#.##)#.###,#');
            assert.equal(element._core.maxNumber, 9999999.9);
          } else {
            assert.equal(element.getAttribute('local-decimal'), '.'); // Negative not supported

            element.setAttribute('format', '#.#');
            assert.equal(element._core.maxNumber, 9.9);

            element.setAttribute('format', '#.###');
            assert.equal(element._core.maxNumber, 9.999);

            element.setAttribute('format', '(###)#.#');
            assert.equal(element._core.maxNumber, 9999.9);

            element.setAttribute('format', '(#,##)#,###.#');
            assert.equal(element._core.maxNumber, 9999999.9);
          }
        });

        // -----------------------------------------------------------------------------------
        // Functionality of MINIMUM (0) and MAXIMUM (format dependent) value.
        // When ranges reached, DIGIT buttons DEACTIVE. Preventing overflow.
        // TODO: Support negative values.
        // -----------------------------------------------------------------------------------

        test('C01 - Default layout behavior when MAX (99999) value is given.', function() {
          element.setAttribute('format', '#####');
          element.setAttribute('number', '99999');

          assert.equal(element.$$('#digit0').$$('#btnUp').disabled, true);
          assert.equal(element.$$('#digit1').$$('#btnUp').disabled, true);
          assert.equal(element.$$('#digit2').$$('#btnUp').disabled, true);
          assert.equal(element.$$('#digit3').$$('#btnUp').disabled, true);
          assert.equal(element.$$('#digit4').$$('#btnUp').disabled, true);

          assert.equal(element.$$('#digit0').$$('#btnDown').disabled, false);
          assert.equal(element.$$('#digit1').$$('#btnDown').disabled, false);
          assert.equal(element.$$('#digit2').$$('#btnDown').disabled, false);
          assert.equal(element.$$('#digit3').$$('#btnDown').disabled, false);
          assert.equal(element.$$('#digit4').$$('#btnDown').disabled, false);
        });

        test('C02 - Default layout behavior when MIN (0) value is given.', function() {
          element.setAttribute('format', '#####');
          element.setAttribute('number', '12345');
          element.setAttribute('number', '0');

          assert.equal(element.$$('#digit0').$$('#btnUp').disabled, false);
          assert.equal(element.$$('#digit1').$$('#btnUp').disabled, false);
          assert.equal(element.$$('#digit2').$$('#btnUp').disabled, false);
          assert.equal(element.$$('#digit3').$$('#btnUp').disabled, false);
          assert.equal(element.$$('#digit4').$$('#btnUp').disabled, false);

          assert.equal(element.$$('#digit0').$$('#btnDown').disabled, true);
          assert.equal(element.$$('#digit1').$$('#btnDown').disabled, true);
          assert.equal(element.$$('#digit2').$$('#btnDown').disabled, true);
          assert.equal(element.$$('#digit3').$$('#btnDown').disabled, true);
          assert.equal(element.$$('#digit4').$$('#btnDown').disabled, true);
        });

        test('C03 - Default format layout INTEGER - thousands divider, ELEMENT kgui-single-digit', function() {
          var nodes;

          if (decimalSeparator === ',') { // Continental European
            // Use '.' as thousand divider.
            element.setAttribute('format', '##.###.###');
          } else {
            // Use ',' as thousand divider.
            element.setAttribute('format', '##,###,###');
          }
          element.setAttribute('number', '12345678');

          nodes = element.$.digits.childNodes;
          assert.equal(nodes.length, 10); // Including numbers and formatters (,.)

          assert.equal(nodes[0].nodeName, 'KGUI-SINGLE-DIGIT');
          assert.equal(nodes[0].digit, '1');

          assert.equal(nodes[1].nodeName, 'KGUI-SINGLE-DIGIT');
          assert.equal(nodes[1].digit, '2');

          assert.equal(nodes[2].nodeName, 'DIV');
          assert.equal(nodes[2].textContent, '.');

          assert.equal(nodes[3].nodeName, 'KGUI-SINGLE-DIGIT');
          assert.equal(nodes[3].digit, '3');

          assert.equal(nodes[4].nodeName, 'KGUI-SINGLE-DIGIT');
          assert.equal(nodes[4].digit, '4');

          assert.equal(nodes[5].nodeName, 'KGUI-SINGLE-DIGIT');
          assert.equal(nodes[5].digit, '5');

          assert.equal(nodes[6].nodeName, 'DIV');
          assert.equal(nodes[6].textContent, '.');

          assert.equal(nodes[7].nodeName, 'KGUI-SINGLE-DIGIT');
          assert.equal(nodes[7].digit, '6');

          assert.equal(nodes[8].nodeName, 'KGUI-SINGLE-DIGIT');
          assert.equal(nodes[8].digit, '7');

          assert.equal(nodes[9].nodeName, 'KGUI-SINGLE-DIGIT');
          assert.equal(nodes[9].digit, '8');
        });

        test('C04 - Optional format as default, using default number value of 0', function() {
          if (decimalSeparator === ',') { // Continental European
            element.setAttribute('format', '(#.##)#'); // NO DECIMAL FRACTIONS !!!!!
          } else {
            element.setAttribute('format', '(#,##)#'); // NO DECIMAL FRACTIONS !!!!!
          }
          assert.equal(element._core.digitCount, 4);
          assert.equal(element._core.decimalCount, 4);
          assert.equal(element._core.fractionCount, 0); // NO DECIMAL FRACTIONS !!!!!
          assert.equal(element._core.formatDecimalMarkPosition, null); // No fractions

          // Visible on screen 0.0, because 0 is the default element.number value
          assert.equal(element.number, '0'); // Visible as '0'
          assert.equal(element.$$('#digit0').digit, '0'); // 1
          assert.equal(element.$$('#digit0').classList.contains('symbol__invisible'), false);
          assert.equal(element.$$('#digit1').digit, '0'); // 10
          assert.equal(element.$$('#digit1').classList.contains('symbol__invisible'), true);
          assert.equal(element.$$('#digit2').digit, '0'); // 100
          assert.equal(element.$$('#digit2').classList.contains('symbol__invisible'), true);
          assert.equal(element.$$('#digit3').digit, '0'); // 1000
          assert.equal(element.$$('#digit3').classList.contains('symbol__invisible'), true);

          assert.equal(element.$$('#token2').classList.contains('symbol__invisible'), true);
        });

        test('C05 - Optional format as default, changing digits', function() {
          // (#,#1)2
          if (decimalSeparator === ',') { // Continental European
            element.setAttribute('format', '(#.##)#'); // DOT as thousand divider
          } else {
            element.setAttribute('format', '(#,##)#'); // COMMA as thousand divider
          }

          // Two digits number
          element.number = '12';
          assert.equal(element.$$('#digit0').digit, '2'); // 1
          assert.equal(element.$$('#digit0').classList.contains('symbol__invisible'), false);

          assert.equal(element.$$('#digit1').digit, '1'); // 10
          assert.equal(element.$$('#digit1').classList.contains('symbol__invisible'), false);

          assert.equal(element.$$('#digit2').digit, '0'); // 100
          assert.equal(element.$$('#digit2').classList.contains('symbol__invisible'), true);

          assert.equal(element.$$('#token2').classList.contains('symbol__invisible'), true);

          assert.equal(element.$$('#digit3').digit, '0'); // 1000
          assert.equal(element.$$('#digit3').classList.contains('symbol__invisible'), true);

          assert.equal(element.$$('#token2').classList.contains('symbol__invisible'), true);

          // three digits number
          element.number = '123';
          assert.equal(element.$$('#digit0').digit, '3'); // 1
          assert.equal(element.$$('#digit0').classList.contains('symbol__invisible'), false);

          assert.equal(element.$$('#digit1').digit, '2'); // 10
          assert.equal(element.$$('#digit1').classList.contains('symbol__invisible'), false);

          assert.equal(element.$$('#digit2').digit, '1'); // 100
          assert.equal(element.$$('#digit2').classList.contains('symbol__invisible'), false);

          assert.equal(element.$$('#token2').classList.contains('symbol__invisible'), true);

          assert.equal(element.$$('#digit3').digit, '0'); // 1000
          assert.equal(element.$$('#digit3').classList.contains('symbol__invisible'), true);

          // Four digits number
          element.number = '1234';
          assert.equal(element.$$('#digit0').digit, '4'); // 1
          assert.equal(element.$$('#digit0').classList.contains('symbol__invisible'), false);

          assert.equal(element.$$('#digit1').digit, '3'); // 10
          assert.equal(element.$$('#digit1').classList.contains('symbol__invisible'), false);

          assert.equal(element.$$('#digit2').digit, '2'); // 100
          assert.equal(element.$$('#digit2').classList.contains('symbol__invisible'), false);

          assert.equal(element.$$('#token2').classList.contains('symbol__invisible'), false);

          assert.equal(element.$$('#digit3').digit, '1'); // 1000
          assert.equal(element.$$('#digit3').classList.contains('symbol__invisible'), false);
        });

        // -----------------------------------------------------------------------------------
        // Functionality working with numbers
        // Every digit in a MULTI DIGITS configuration, specified by 'format'.
        // Has a +/- button to increase decrease a specific digit.
        // If a single digit crosses a boundary, like from 9 to 0 (counting up), or
        // from 0 to 9 (counting down.) The neigbouring digits should follow also accordingly.
        // Example showing number '10' and decreasing digit '0' to '9'.
        // Digit '1' will be '0', to show '09' as total number.
        // -----------------------------------------------------------------------------------

        test('D01 - Test click behavior (#)#, with value 9', function(done) {
          var eventBoundaryCounter = 0;

          // Prepare
          element.addEventListener('digit-boundary-crossed', function(e) {
            eventBoundaryCounter += 1;
            if (eventBoundaryCounter === 2) {
              done();
            }
          });
          if (decimalSeparator === ',') { // Continental European
            element.setAttribute('format', '(#)#');
          } else {
            element.setAttribute('format', '(#)#');
          }
          element.setAttribute('number', '9'); // On display just '9'.

          // Test begin situation (0)09
          assert.equal(element.$$('#digit0').digit, '9');
          assert.equal(element.$$('#digit0').classList.contains('symbol__invisible'), false);
          assert.equal(element.$$('#digit1').digit, '0');
          assert.equal(element.$$('#digit1').classList.contains('symbol__invisible'), true);

          // Test mouse click on + #9
          eventFire(element.$$('#digit0').$.btnUp, 'click'); // FIRE EVENT 'digit-boundary-crossed'
          assert.equal(element.$$('#digit0').digit, '0');
          assert.equal(element.$$('#digit0').classList.contains('symbol__invisible'), false);
          assert.equal(element.$$('#digit1').digit, '1');
          assert.equal(element.$$('#digit1').classList.contains('symbol__invisible'), false);
          assert.equal(element.number, '10');
          assert.equal(element.getAttribute('number'), '10');

          // Test mouse click on - #0
          eventFire(element.$$('#digit0').$.btnDown, 'click'); // FIRE EVENT 'digit-boundary-crossed'
          assert.equal(element.$$('#digit0').digit, '9');
          assert.equal(element.$$('#digit0').classList.contains('symbol__invisible'), false);
          assert.equal(element.$$('#digit1').digit, '0');
          assert.equal(element.$$('#digit1').classList.contains('symbol__invisible'), true);
          assert.equal(element.number, '9');
          assert.equal(element.getAttribute('number'), '9');

          // Test MIN buttons, when LOW reached
          eventFire(element.$$('#digit0').$.btnDown, 'click'); // Make 08
          eventFire(element.$$('#digit0').$.btnDown, 'click'); // Make 07
          eventFire(element.$$('#digit0').$.btnDown, 'click'); // Make 06
          eventFire(element.$$('#digit0').$.btnDown, 'click'); // Make 05
          eventFire(element.$$('#digit0').$.btnDown, 'click'); // Make 04
          eventFire(element.$$('#digit0').$.btnDown, 'click'); // Make 03
          eventFire(element.$$('#digit0').$.btnDown, 'click'); // Make 02
          eventFire(element.$$('#digit0').$.btnDown, 'click'); // Make 01
          eventFire(element.$$('#digit0').$.btnDown, 'click'); // Make 00
          assert.equal(element.$$('#digit0').digit, '0');
          assert.equal(element.$$('#digit1').digit, '0');
          assert.equal(element.$$('#digit0').$.btnDown.disabled, true);
          assert.equal(element.$$('#digit1').$.btnDown.disabled, true);
          assert.equal(element.$$('#digit0').$.btnUp.disabled, false);
          assert.equal(element.$$('#digit1').$.btnUp.disabled, false);
          assert.equal(element.number, '0');
          assert.equal(element.getAttribute('number'), '0');

          // Test MAX buttons, when HIGH reached
          eventFire(element.$$('#digit1').$.btnUp, 'click'); // Make 10
          eventFire(element.$$('#digit1').$.btnUp, 'click'); // Make 20
          eventFire(element.$$('#digit1').$.btnUp, 'click'); // Make 30
          eventFire(element.$$('#digit1').$.btnUp, 'click'); // Make 40
          eventFire(element.$$('#digit1').$.btnUp, 'click'); // Make 50
          eventFire(element.$$('#digit1').$.btnUp, 'click'); // Make 60
          eventFire(element.$$('#digit1').$.btnUp, 'click'); // Make 70
          eventFire(element.$$('#digit1').$.btnUp, 'click'); // Make 80
          eventFire(element.$$('#digit1').$.btnUp, 'click'); // Make 90
          eventFire(element.$$('#digit1').$.btnUp, 'click'); // Make 99
          assert.equal(element.$$('#digit0').digit, '9');
          assert.equal(element.$$('#digit1').digit, '9');
          assert.equal(element.$$('#digit0').$.btnDown.disabled, false);
          assert.equal(element.$$('#digit1').$.btnDown.disabled, false);
          assert.equal(element.$$('#digit0').$.btnUp.disabled, true);
          assert.equal(element.number, '99');
          assert.equal(element.getAttribute('number'), '99');
          assert.equal(element.$$('#digit1').$.btnUp.disabled, true);
        });

        test('D02 - Test click behavior on #####, with value 9999', function(done) {
          var eventBoundaryCounter = 0;

          // Prepare
          element.addEventListener('digit-boundary-crossed', function() {
            eventBoundaryCounter += 1;
            if (eventBoundaryCounter === 3) {
              done();
            }
          });
          element.setAttribute('format', '#####');
          element.setAttribute('number', '9999'); // On display just '9'.

          // Test begin situation
          assert.equal(element.$$('#digit0').digit, '9');
          assert.equal(element.$$('#digit1').digit, '9');
          assert.equal(element.$$('#digit2').digit, '9');
          assert.equal(element.$$('#digit3').digit, '9');
          assert.equal(element.$$('#digit4').digit, '0');
          assert.equal(element.$$('#digit0').classList.contains('symbol__invisible'), false);
          assert.equal(element.$$('#digit1').classList.contains('symbol__invisible'), false);
          assert.equal(element.$$('#digit1').classList.contains('symbol__invisible'), false);
          assert.equal(element.$$('#digit1').classList.contains('symbol__invisible'), false);
          assert.equal(element.$$('#digit1').classList.contains('symbol__invisible'), false);

          // Test mouse click on + #9##
          eventFire(element.$$('#digit2').$.btnUp, 'click'); // FIRE EVENT 'digit-boundary-crossed'
          assert.equal(element.$$('#digit0').digit, '9');
          assert.equal(element.$$('#digit1').digit, '9');
          assert.equal(element.$$('#digit2').digit, '0');
          assert.equal(element.$$('#digit3').digit, '0');
          assert.equal(element.$$('#digit4').digit, '1');

          // Test mouse click on + ####9
          eventFire(element.$$('#digit0').$.btnUp, 'click'); // FIRE EVENT 'digit-boundary-crossed'
          assert.equal(element.$$('#digit0').digit, '0');
          assert.equal(element.$$('#digit1').digit, '0');
          assert.equal(element.$$('#digit2').digit, '1');
          assert.equal(element.$$('#digit3').digit, '0');
          assert.equal(element.$$('#digit4').digit, '1');

          // Test mouse click on - -####
          eventFire(element.$$('#digit4').$.btnDown, 'click');
          assert.equal(element.$$('#digit0').digit, '0');
          assert.equal(element.$$('#digit1').digit, '0');
          assert.equal(element.$$('#digit2').digit, '1');
          assert.equal(element.$$('#digit3').digit, '0');
          assert.equal(element.$$('#digit4').digit, '0');
          assert.equal(element.$$('#digit3').classList.contains('symbol__invisible'), false);
          assert.equal(element.$$('#digit4').classList.contains('symbol__invisible'), false);
          assert.equal(element.$$('#digit0').getAttribute('min'), '');
          assert.equal(element.$$('#digit1').getAttribute('min'), '');
          assert.equal(element.$$('#digit2').getAttribute('min'), '');
          assert.equal(element.$$('#digit3').getAttribute('min'), '');
          assert.equal(element.$$('#digit4').getAttribute('min'), '');

          // Test mouse click on - -####, value = '00100'.
          eventFire(element.$$('#digit4').$.btnDown, 'click'); // FIRE EVENT 'digit-boundary-crossed'
          assert.equal(element.$$('#digit0').digit, '0');
          assert.equal(element.$$('#digit1').digit, '0');
          assert.equal(element.$$('#digit2').digit, '0');
          assert.equal(element.$$('#digit3').digit, '0');
          assert.equal(element.$$('#digit4').digit, '0');
          assert.equal(element.$$('#digit0').getAttribute('min'), 0);
          assert.equal(element.$$('#digit1').getAttribute('min'), 0);
          assert.equal(element.$$('#digit2').getAttribute('min'), 0);
          assert.equal(element.$$('#digit3').getAttribute('min'), 0);
          assert.equal(element.$$('#digit4').getAttribute('min'), 0);
        });

        test('D03 - Test click behavior with one fraction ####.#', function() {
          // Prepare fractions
          if (decimalSeparator === ',') { // Continental European
            element._paintFormat('####,#');
            element.setAttribute('number', '999,9'); //
          } else {
            element._paintFormat('####.#');
            element.setAttribute('number', '999.9'); //
          }
          assert.equal(element.$$('#digit0').digit, '9');
          assert.equal(element.$$('#digit1').digit, '9');
          assert.equal(element.$$('#digit2').digit, '9');
          assert.equal(element.$$('#digit3').digit, '9');
          assert.equal(element.$$('#digit4').digit, '0');

          // Test mouse click on
          eventFire(element.$$('#digit0').$.btnUp, 'click');
          assert.equal(element.$$('#digit0').digit, '0');
          assert.equal(element.$$('#digit1').digit, '0');
          assert.equal(element.$$('#digit2').digit, '0');
          assert.equal(element.$$('#digit3').digit, '0');
          assert.equal(element.$$('#digit4').digit, '1');
          assert.equal(element._number, 1000);
        });

        test('D04 - Test click behavior with four fractions #.####', function() {
          // Prepare fractions
          if (decimalSeparator === ',') { // Continental European
            element._paintFormat('#,####');
            element.setAttribute('number', '0,9999');
          } else {
            element._paintFormat('#.####');
            element.setAttribute('number', '0.9999');
          }
          assert.equal(element.$$('#digit0').digit, '9');
          assert.equal(element.$$('#digit1').digit, '9');
          assert.equal(element.$$('#digit2').digit, '9');
          assert.equal(element.$$('#digit3').digit, '9');
          assert.equal(element.$$('#digit4').digit, '0');

          // Test mouse click on
          eventFire(element.$$('#digit0').$.btnUp, 'click');
          assert.equal(element.$$('#digit0').digit, '0');
          assert.equal(element.$$('#digit1').digit, '0');
          assert.equal(element.$$('#digit2').digit, '0');
          assert.equal(element.$$('#digit3').digit, '0');
          assert.equal(element.$$('#digit4').digit, '1');
          assert.equal(element._number, 1);
        });

        // -----------------------------------------------------------------------------------
        // Function _paintFormat(formtString)
        // Writes the format layout of digits, DECIMAL MARK and other dividers.
        // Without using actial digit numbers. It uses the default 0.
        // -----------------------------------------------------------------------------------

        test('E01 - Function _paintFormat(formatString)', function() {
          // Check default
          assert.equal(element.format, '(##)#');
          // Digit ID's from right to left, as '210'
          assert.equal(element.$$('#digit0').digit, '0');
          assert.equal(element.$$('#digit1').digit, '0');
          assert.equal(element.$$('#digit2').digit, '0');
          assert.equal(element.$$('#digit3'), null); // Does not exits

          // Prepare 6 digits right to left '5.4.3,210
          if (decimalSeparator === ',') { // Continental European
            element._paintFormat('(#.#).#,###');
          } else {
            element._paintFormat('(#,#),#.###');
          }

          assert.equal(element.$$('#digit0').digit, '0');
          assert.equal(element.$$('#digit1').digit, '0');
          assert.equal(element.$$('#digit2').digit, '0');
          assert.equal(element.$$('#digit3').digit, '0');
          assert.equal(element.$$('#digit4').digit, '0');
          assert.equal(element.$$('#digit5').digit, '0');
          assert.equal(element.$$('#digit6'), null); // Does not exits

          assert.equal(element.$$('#token2').classList.contains('digit--thousand'), true);
          assert.equal(element.$$('#token5').classList.contains('digit--thousand'), true);
          assert.equal(element.$$('#token7').classList.contains('digit--decimal'), true);

          assert.equal(element.$$('#token2').classList.contains('symbol__invisible'), true);
          assert.equal(element.$$('#token5').classList.contains('symbol__invisible'), false);
          assert.equal(element.$$('#token7').classList.contains('symbol__invisible'), false);
        });

        // -----------------------------------------------------------------------------------
        // Function _writeNumberAsDigits()
        // The property element._number (of type Number) is used as input.
        // -----------------------------------------------------------------------------------

        test('F01 - Function _writeNumberAsDigits()', function() {
          // Check default
          assert.equal(element.format, '(##)#');
          assert.equal(element._number, 0);
          assert.equal(element.$$('#digit0').digit, '0');
          assert.equal(element.$$('#digit1').digit, '0');
          assert.equal(element.$$('#digit2').digit, '0');
          assert.equal(element.$$('#digit3'), null); // Does not exits

          // Change the number
          element.number = '987';
          assert.equal(element._number, 987);
          // In real, changing property element._number, already invoked _writeNumberAsDigits()
          assert.equal(element.$$('#digit0').digit, '7');
          assert.equal(element.$$('#digit1').digit, '8');
          assert.equal(element.$$('#digit2').digit, '9');
          assert.equal(element.$$('#digit3'), null); // Does not exits

          // This call has no use, but we check it still.
          element._writeNumberAsDigits();
          assert.equal(element.$$('#digit0').digit, '7');
          assert.equal(element.$$('#digit1').digit, '8');
          assert.equal(element.$$('#digit2').digit, '9');
          assert.equal(element.$$('#digit3'), null); // Does not exits
        });

        // -----------------------------------------------------------------------------------
        // Function _getDigitFloatStr(), get the multi digits number value as a string.
        // -----------------------------------------------------------------------------------

        test('F01 - Function _getDigitFloatStr()', function() {
          // Default situation
          assert.equal(element._number, 0);
          assert.equal(element._getDigitFloatStr(), '000');
          // Test
          element.number = '12';
          assert.equal(element._getDigitFloatStr(), '012');
        });

        test('F02 - Function _getDigitFloatStr() in combination with diverent formats', function() {
          // Prepare
          if (decimalSeparator === ',') { // Continental European
            element.setAttribute('format', '###,##');
          } else {
            element.setAttribute('format', '###.##');
          }

          // Test
          element.number = '12.95';
          assert.equal(element._getDigitFloatStr(), '012.95');
          assert.equal(element._number, 12.95);

          // Test
          element.number = '4.9';
          assert.equal(element._getDigitFloatStr(), '004.90');
          assert.equal(element._number, 4.9);
        });

        // -----------------------------------------------------------------------------------
        // Function _getDigitFloatStr(), get the multi digits number value as a string.
        // -----------------------------------------------------------------------------------

        test('G01 - SPACE Diver (thousands), is ISO standard', function() {
          // Prepare
          if (decimalSeparator === ',') { // Continental European
            element.setAttribute('format', '### ### ###');
          } else {
            element.setAttribute('format', '### ### ###');
          }

          // Test
          assert.equal(element._getDigitFloatStr(), '000000000');

          // Prepare
          element.setAttribute('number', '87654321');

          // Test
          assert.equal(element._getDigitFloatStr(), '087654321');
        });

        // -----------------------------------------------------------------------------------
        // Function _digitBoundaryCrossed(), is tested indirectly. Because function is invoked
        // by EVENT 'digit-boundary-crossed', see test 'D##'.
        // -----------------------------------------------------------------------------------

        // -----------------------------------------------------------------------------------
        // Function _checkSingleDigitChanged(), is tested indirectly. Because function is invoked
        // by EVENT 'digit-changed', see test 'D##'.
        // -----------------------------------------------------------------------------------

        // -----------------------------------------------------------------------------------
        // Function _paintNumber(), is invoked when changing attribute (property) 'number' or 'format'.
        // -----------------------------------------------------------------------------------
      });
    </script>
  </body>
</html>
