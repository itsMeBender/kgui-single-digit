<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="kgui-single-digit.html">
<!--
`kgui-multi-digits` manipulate multiple single digits

@demo demo/index-multi-digits.html
-->

<dom-module id="kgui-multi-digits">
  <template>
    <style>
      :host {
        display: block;
      }
      .symbol__invisible {
        visibility: hidden;   /* Because we want to reserve the space */
      }
      .digit--divider {
        position: relative;
        top: -0.6em;
        display: inline-block;
        font-size: 4em;
      }
      kgui-single-digit {
        margin: 0 -0.2em;        
      }
    </style>
    
    <div class="digits--container" id="digits">
    </div>

  </template>

  <script>
    Polymer({

      is: 'kgui-multi-digits',

      properties: {

        // Act as a SingleTon to keep `multi digits` data in synq.
        _core: {
          type: Object,
          readOnly: true,
          value: function() {
            return {digits: [], format: null};
          },
        },

        // Digits format and number range (0 - 9999.9)
        format: {
          type: String,
          value: '(#,##)#.#',
          reflectToAttribute: true,
        },

        // Digit value
        number: {
          type: Number,
          value: 0,
          notify: true,
          reflectToAttribute: true,
        },

        // Local decimal separator DOT or COMMA
        localDecimal: {
          type: String,
          value: (1.1).toLocaleString().replace(/1/g, ''),
          readOnly: true,
          reflectToAttribute: true,
        },
      },

      observers: [
        '_updateDisplay(format, number)',
      ],

      // Build the number structure according to validated `format` layout.
      writeFormat: function(_format) {
        // The 'format' string is important because, it shows the maximum size of digits.
        // And which digits are always visible, at least with a '0'.
        // The '(#...)', part is hidden when the number needs it. The other part is always visible.
        // The number (float) is centered around the localized decimal mark, a '.' or ','
        _format = _format ? _format : this.format;

        /**
         * Interpretate a `_format` string on
         *  - '#', a single digit
         *  - ','|'.'- a divider
         *  - TODO: SPACE as divider is ISO norm
         * Example "(##)#.###,##" is a number with floating point divider at ','.
         * Maximum number range '999.999,99', initial visible as '0.000,00'.
         * @param {String} _format of the number
         * @return {Array} of objects, containing META information of the created kgui-single-digit elements.
         */
        function buildDigitFormatList(_format) {
          var symbolCount;
          var elementID;
          var formatLst = [];
          var formatLength = _format.length;
          var i;
          var isDecimalMark;
          var isThousandMark;
          var node;
          var optional = false; // Are digits part of the optional part of the form, as in '(###)'.
          var textNode;

          this._core.decimalMarkPosition = undefined;
          this._core.fractionCount = 0; // The number of digits after the decimal mark
          this._core.decimalCount = 0; // The number of digits before the decimal mark
          this._core.symbolCount = _format.match(/#/g).length; // Expect at least 1 or more digits to create
          this._core.decimalSeparator = this._core.decimalSeparator
                                      ? this._core.decimalSeparator
                                      : (1.1).toLocaleString().replace(/1/g, '');
          this._core.thousandSeparator = this._core.thousandSeparator
                                       ? this._core.thousandSeparator
                                       : (1111).toLocaleString().replace(/1/g, '');
          symbolCount = this._core.symbolCount;

          // Determine LOCAL decimal '.'|',' separator sign
          // First build the digits sequence, as instructed by the format string.
          // (##)#,###.## ~ whereby the '(##)' is the optional (hidden) part.

          for (i = 0; i < formatLength; i += 1) {
            isDecimalMark = false;
            isThousandMark = false;

            switch (_format.substr(i, 1)) {
              case this._core.decimalSeparator:
                isDecimalMark = true;
                this._core.decimalMarkPosition = i;
                node = document.createElement('DIV');
                textNode = document.createTextNode(this._core.decimalSeparator);
                node.setAttribute('id', elementID = 'token' + i);
                node.appendChild(textNode);
                if (optional) {
                  node.classList.add('symbol__invisible', 'digit--divider', 'digit--decimal');
                } else {
                  node.classList.add('digit--divider', 'digit--decimal');
                }
                this._core.domAPI.appendChild(node);
                break;

              case this._core.thousandSeparator:
                isThousandMark = true;
                node = document.createElement('DIV');
                textNode = document.createTextNode(this._core.thousandSeparator);
                node.setAttribute('id', elementID = 'token' + i);
                node.appendChild(textNode);
                if (optional) {
                  node.classList.add('symbol__invisible', 'digit--divider', 'digit--thousand');
                } else {
                  node.classList.add('digit--divider', 'digit--thousand');
                }
                this._core.domAPI.appendChild(node);
                break;

              case '(':
                optional = true; // Create 'kgui-single-digit', elements but make them invisible
                break;

              case ')':
                optional = false; // Create visible 'kgui-single-digit' elements
                break;

              default: // '#' token
                if (this._core.decimalMarkPosition === undefined) { // Is set, so decimal mark is known in format string.
                  this._core.decimalCount += 1; // The number of digits before the decimal mark
                } else {
                  this._core.fractionCount += 1; // The number of digits after the decimal mark
                }

                node = document.createElement('KGUI-SINGLE-DIGIT');
                symbolCount -= 1;
                node.setAttribute('id', elementID = 'digit' + symbolCount); // 'token2' 'token1' , 'token0'
                if (optional) {
                  node.setAttribute('class', 'symbol__invisible');
                }
                this._core.domAPI.appendChild(node);

                // Needed otherwise SHADOW or SHADY will fail, not sure why
                // https://www.polymer-project.org/1.0/docs/devguide/events
                this.listen(node, 'digit-boundary-crossed', '_digitBoundaryCrossed');
                this.listen(node, 'digit-changed', '_checkSingleDigitChanged');
            } // EndSwitch

            switch (_format.substr(i, 1)) {
              case '(':
                // Fall through
              case ')':
                break;
              default:
                // Build a list to improve interaction NUMBER FORMAT
                // First item in the list is the last number (digit).
                formatLst.unshift({
                  id: elementID,
                  isDecimal: isDecimalMark,
                  isDigit: _format.substr(i, 1) === '#' ? true : false,
                  isOptional: optional,
                  isThousand: isThousandMark,
                  node: node,
                });
            }
          } // EndFor loop

          return formatLst;
        }

        // Has format changed?
        if (_format !== this._core.format) {
          // console.log('writeFormat()');
          // Yes, Create new format as specified
          this._core.format = _format;
          this._core.domAPI = this._core.domAPI ? this._core.domAPI : Polymer.dom(this.$.digits);

          // Remove, if available, the old digits first.
          while (this._core.domAPI.firstChild) {
            // https://www.polymer-project.org/1.0/docs/devguide/events
            this.unlisten(this._core.domAPI.firstChild, 'digit-boundary-crossed', '_digitBoundaryCrossed');
            this.unlisten(this._core.domAPI.firstChild, 'digit-changed', '_checkSingleDigitChanged');
            this._core.domAPI.removeChild(this._core.domAPI.firstChild);
          }

          // Build the new FORMAT sequence, digit values will be filled in later.
          this._core.symbols = buildDigitFormatList.call(this, _format);

          // buildDigitFormatList() also determine `decimalSeparator`, `thousandSeparator`
          // Determine maximum FLOAT number.
          _format = _format.replace(/[()]/g, '');
          _format = _format.replace(new RegExp('\\' + this._core.thousandSeparator, 'g'), '');
          _format = _format.replace(new RegExp('\\' + this._core.decimalSeparator), '.');
          this._core.maxNumber = parseFloat(_format.replace(/#/g, '9'), 10);
        }
      },

      // Attribute `number` changed, update digits.
      writeNumberAsDigits: function(_float) {
        // console.log('writeNumberAsDigits(' + _float + '):');
        var digitObj;
        var digitValue;
        var i;
        var idx;
        var floatStr = '';

        // Changing a single digit VALUE, or MIN, MAX. Can invoke writeNumberAsDigits() again, while arlread y 'busy'.
        // Set the digit number values, starting from float '.' or from the left.
        idx = this._core.decimalMarkPosition;
        if (idx > 0) {
          // It is a FLOAT
          idx = (idx >= 0) ? ++idx : 0; // If not, first DIGIT alway on position 0. Or next to the '.'
        } else {
          // INTEGER Display

          // Build prefix zero's.
          for (i = 0; i < this._core.decimalCount; i += 1) {
            floatStr += '0';
          }
          floatStr += parseFloat(_float, 10);
          floatStr = floatStr.slice(this._core.decimalCount * -1);
          idx = this._core.decimalCount - 1;

          // Walk through digits, from RIGHT:0 to LEFT:#
          for (i = 0; i < this._core.symbols.length; i += 1) {
            digitObj = this._core.symbols[i]; // Can be a DIGIT, DECIMAL MARK, THOUSANT DIVIDER
            if (digitObj.isDigit) {
              digitValue = floatStr.substr(idx, 1); // From RIGHT to LEFT
              digitObj.node.digit = parseInt(digitValue, 10);
              idx -= 1;
            }
          }
        }
      },

      // If valid it returns a valid `Number`, by default 0.
      validateToFloat: function(_number) {
        // Writing and testing https://regex101.com/
        // TODO: No support yet for + and - sign.
        var retval;

        _number = _number ? _number : this.number;

        if (this.localDecimal === '.') {
          retval = /^\d+(\.\d+){1}$|^\d+$/.test(_number); // International - JavaScript
        } else {
          retval = /^\d+(,\d+){1}$|^\d+$/.test(_number); // Dutch
          if (retval) {
            // Make it a JavaScript Number
            _number = parseFloat(_number.toString().replace(',', '.'), 10);
          }
        }

        this.number = retval ? parseFloat(_number, 10) : 0; // TODO: decimal localized
        return this.number;
      },

      // True when correct validation of digit `format`. Example "(##)#,#".
      validateFormat: function(_format) {
        var i;
        var bracketA;
        var bracketB = 0; // Only one occurence of ( and ).
        // Writing and testing https://regex101.com/
        var validation = [
          {regx: /(?=^(#|\(#))(?=.*#$)/, msg: 'Always start with `#` OR `(#` and always end with an `#`.'},
          {regx: /^[#.,()]+$/, msg: 'Allowed characters `.,#()`.'},
          {regx: /^\(.+\)|^#/, msg: 'Missing end `)`.'},
        ];

        _format = _format ? _format : this.format;

        // Always need a format, evenn if user has used (by accident0 removeAttribute()
        if (!_format) {
          this.format = '(#,##)#.#'; // This will activate _updateDisplay(format, number)
          return true;
        }

        // Walk through REGEXPR validations
        for ( i = 0; i < validation.length; i += 1) {
          if (!validation[i].regx.test(_format)) {
            throw new Error(validation[i].msg, 'kgui-multi-digits.html');
          }
        }

        // Could not find a REGEXPR solution for REGEXPR on single par "(...)"
        bracketA = _format.match(/\(/g);
        bracketA = bracketA === null ? 0 : bracketA.length; // Accept 0, 1 occurrences
        bracketB = _format.match(/\)/g);
        bracketB = bracketB === null ? 0 : bracketB.length; // Accept 0, 1 occurrences

        if (!(bracketA < 2 && bracketA === bracketB) || bracketA > 1) {
          throw new Error('No matching `()`.', 'kgui-multi-digits.html');
        }

        return true;
      },

      // A digit has crossed the number boundary, like from 9 to 0.
      _digitBoundaryCrossed: function(e) {
        // console.log('_digitBoundaryCrossed()');
        var digitID = parseInt(e.target.id.substr(5), 10);
        var factor;
        var float = parseInt(this._getDigitFloatStr(), 10); // 000.00
        var floatPos = this._core.decimalMarkPosition; // Example above '4', start counting from the left
        var max = this._core.maxNumber; // Maximum value of the number (float), specified by format. Like 9, 99, 999, 9999, 9.99

        floatPos = floatPos ? floatPos : 0; // CAN BE 'undefined', when float does not contain a decimal marker.

        // Depending on which DIGIT is changed (9to0, 0to9) and the floating character postion,
        // a factor of ONE is calculated.
        // For a number of '1.23', clicking the '3' gives factor '0.01'.
        // For a number of '1.23', clicking the '2' gives factor '0.1'.
        // For a number of '1.23', clicking the '1' gives factor '1'.
        factor = 1 / Math.pow(10, floatPos) * Math.pow(10, digitID);

        // detail.new digit value vs. detail.old and previous value.
        float = float + factor * 10 * e.detail.increment;

        if (float <= 0) { // Check for MINIMUM value
          float = 0;
        }
        if (float >= max) { // Check for MAXIMUM value
          float = max;
        }

        this.writeNumberAsDigits(float); // New FLOAT number calculated, write complete number
      },

      // Check if single digit change leads to a MINIMUM or MAXIMUM value
      _checkSingleDigitChanged: function() {
        // console.log('_checkSingleDigitChanged() - new number:', newFloat);
        // Get fist the current actual FLOAT NUMBER, as specified by format.
        // TODO: Make this.number localized (now is always JS format - dot.)
        var i;
        var newFloat = parseFloat(this._getDigitFloatStr(), 10);
        var optionActive;
        var symbol;

        if (this._core.maxNumber === newFloat) {
          // MAXIMUM number displayed, CAN'T GO HIGHER
          this._core.symbols.forEach(function(symbol, i) {
            if (symbol.isDigit) {
              symbol.node.max = '9';
              symbol.node.classList.remove('symbol__invisible');
            }
          });
        } else if (newFloat === 0) {
          // MINIMUM number displayed, CAN'T GO LOWER
          this._core.symbols.forEach(function(symbol, i) {
            if (symbol.isDigit) {
              symbol.node.min = '0';
            }
          });
        } else {
          // RESET
          this._core.symbols.forEach(function(symbol, i) {
            if (symbol.isDigit) {
              symbol.node.min = '';
              symbol.node.max = '';
            }
          });
        }

        optionActive = true; // To check if format options are active.
        if (this._core.maxNumber !== newFloat) {
          // Check visibility of FORMAT ELEMENTS, going from LEFT to RIGHT
          for (i = this._core.symbols.length - 1; i >= 0; i -= 1) {
            symbol = this._core.symbols[i]; // Symbol can be a DIGIT, DECIMAL MARK, THOUSANT DIVIDER
            if (symbol.isDigit) {
              if (optionActive) {
                if (symbol.isOptional && symbol.node.digit === 0) {
                  // No prefix ZERO's visible
                  symbol.node.classList.add('symbol__invisible');
                } else {
                  optionActive = false; // NO optional format place holder OR a none ZERo digit value.
                  symbol.node.classList.remove('symbol__invisible');
                }
              } else {
                // Format option overruled by number data, always show.
                symbol.node.classList.remove('symbol__invisible');           
              }
            } else {
              if (symbol.isOptional && optionActive) {
                symbol.node.classList.add('symbol__invisible');
              }
            }
          }
        }
        this.number = newFloat; // TODO: decimal localized
      },

      // Get the digits number as FLOAT string
      _getDigitFloatStr: function() {
        var floatStr = '';

        this._core.symbols.forEach(function(item, idx) {
          if (item.isDigit) {
            floatStr = item.node.digit + floatStr;
          } else if (item.isDecimal) {
            // TODO: Localized
            floatStr = '.' + floatStr;
          }
        });
        return floatStr;
      },

      // Update digit display with input from `format` and `number`
      _updateDisplay: function(_format, _number) {
        if (this.validateFormat(_format)) {
          this.writeFormat(_format);
          this.writeNumberAsDigits(this.validateToFloat(_number));
        }
      },

    });
  </script>
</dom-module>
